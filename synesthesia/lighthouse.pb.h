// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: lighthouse.proto

#ifndef PROTOBUF_lighthouse_2eproto__INCLUDED
#define PROTOBUF_lighthouse_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace lighthouse {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_lighthouse_2eproto();
void protobuf_AssignDesc_lighthouse_2eproto();
void protobuf_ShutdownFile_lighthouse_2eproto();

class Command;
class Connect;
class Disconnect;
class Hello;
class En_LED;
class Dis_LED;
class Set_DC;
class Send_Data;
class Lat_Data;
class Num_Brds;
class Response;
class Error;
class Connect_Resp;
class Num_Brds_Resp;

enum Command_Commands {
  Command_Commands_CONNECT = 1,
  Command_Commands_DISCONNECT = 2,
  Command_Commands_HELLO = 3,
  Command_Commands_EN_LED = 4,
  Command_Commands_DIS_LED = 5,
  Command_Commands_SET_DC = 6,
  Command_Commands_SEND_DATA = 7,
  Command_Commands_LAT_DATA = 8,
  Command_Commands_NUM_BRDS = 9
};
bool Command_Commands_IsValid(int value);
const Command_Commands Command_Commands_Commands_MIN = Command_Commands_CONNECT;
const Command_Commands Command_Commands_Commands_MAX = Command_Commands_NUM_BRDS;
const int Command_Commands_Commands_ARRAYSIZE = Command_Commands_Commands_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_Commands_descriptor();
inline const ::std::string& Command_Commands_Name(Command_Commands value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_Commands_descriptor(), value);
}
inline bool Command_Commands_Parse(
    const ::std::string& name, Command_Commands* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_Commands>(
    Command_Commands_descriptor(), name, value);
}
enum Error_Errors {
  Error_Errors_NO_BRD = 1,
  Error_Errors_NO_PORT = 2,
  Error_Errors_TEMP = 3,
  Error_Errors_LOD = 4,
  Error_Errors_UNKWN_CMD = 5,
  Error_Errors_UNFMD_CMD = 6
};
bool Error_Errors_IsValid(int value);
const Error_Errors Error_Errors_Errors_MIN = Error_Errors_NO_BRD;
const Error_Errors Error_Errors_Errors_MAX = Error_Errors_UNFMD_CMD;
const int Error_Errors_Errors_ARRAYSIZE = Error_Errors_Errors_MAX + 1;

const ::google::protobuf::EnumDescriptor* Error_Errors_descriptor();
inline const ::std::string& Error_Errors_Name(Error_Errors value) {
  return ::google::protobuf::internal::NameOfEnum(
    Error_Errors_descriptor(), value);
}
inline bool Error_Errors_Parse(
    const ::std::string& name, Error_Errors* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Error_Errors>(
    Error_Errors_descriptor(), name, value);
}
// ===================================================================

class Command : public ::google::protobuf::Message {
 public:
  Command();
  virtual ~Command();
  
  Command(const Command& from);
  
  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();
  
  void Swap(Command* other);
  
  // implements Message ----------------------------------------------
  
  Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Command_Commands Commands;
  static const Commands CONNECT = Command_Commands_CONNECT;
  static const Commands DISCONNECT = Command_Commands_DISCONNECT;
  static const Commands HELLO = Command_Commands_HELLO;
  static const Commands EN_LED = Command_Commands_EN_LED;
  static const Commands DIS_LED = Command_Commands_DIS_LED;
  static const Commands SET_DC = Command_Commands_SET_DC;
  static const Commands SEND_DATA = Command_Commands_SEND_DATA;
  static const Commands LAT_DATA = Command_Commands_LAT_DATA;
  static const Commands NUM_BRDS = Command_Commands_NUM_BRDS;
  static inline bool Commands_IsValid(int value) {
    return Command_Commands_IsValid(value);
  }
  static const Commands Commands_MIN =
    Command_Commands_Commands_MIN;
  static const Commands Commands_MAX =
    Command_Commands_Commands_MAX;
  static const int Commands_ARRAYSIZE =
    Command_Commands_Commands_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Commands_descriptor() {
    return Command_Commands_descriptor();
  }
  static inline const ::std::string& Commands_Name(Commands value) {
    return Command_Commands_Name(value);
  }
  static inline bool Commands_Parse(const ::std::string& name,
      Commands* value) {
    return Command_Commands_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .lighthouse.Command.Commands cmd_type = 1;
  inline bool has_cmd_type() const;
  inline void clear_cmd_type();
  static const int kCmdTypeFieldNumber = 1;
  inline ::lighthouse::Command_Commands cmd_type() const;
  inline void set_cmd_type(::lighthouse::Command_Commands value);
  
  // optional .lighthouse.Connect connect = 2;
  inline bool has_connect() const;
  inline void clear_connect();
  static const int kConnectFieldNumber = 2;
  inline const ::lighthouse::Connect& connect() const;
  inline ::lighthouse::Connect* mutable_connect();
  inline ::lighthouse::Connect* release_connect();
  
  // optional .lighthouse.Disconnect disconnect = 3;
  inline bool has_disconnect() const;
  inline void clear_disconnect();
  static const int kDisconnectFieldNumber = 3;
  inline const ::lighthouse::Disconnect& disconnect() const;
  inline ::lighthouse::Disconnect* mutable_disconnect();
  inline ::lighthouse::Disconnect* release_disconnect();
  
  // optional .lighthouse.Hello hello = 4;
  inline bool has_hello() const;
  inline void clear_hello();
  static const int kHelloFieldNumber = 4;
  inline const ::lighthouse::Hello& hello() const;
  inline ::lighthouse::Hello* mutable_hello();
  inline ::lighthouse::Hello* release_hello();
  
  // optional .lighthouse.En_LED en_led = 5;
  inline bool has_en_led() const;
  inline void clear_en_led();
  static const int kEnLedFieldNumber = 5;
  inline const ::lighthouse::En_LED& en_led() const;
  inline ::lighthouse::En_LED* mutable_en_led();
  inline ::lighthouse::En_LED* release_en_led();
  
  // optional .lighthouse.Dis_LED dis_led = 6;
  inline bool has_dis_led() const;
  inline void clear_dis_led();
  static const int kDisLedFieldNumber = 6;
  inline const ::lighthouse::Dis_LED& dis_led() const;
  inline ::lighthouse::Dis_LED* mutable_dis_led();
  inline ::lighthouse::Dis_LED* release_dis_led();
  
  // optional .lighthouse.Set_DC set_dc = 7;
  inline bool has_set_dc() const;
  inline void clear_set_dc();
  static const int kSetDcFieldNumber = 7;
  inline const ::lighthouse::Set_DC& set_dc() const;
  inline ::lighthouse::Set_DC* mutable_set_dc();
  inline ::lighthouse::Set_DC* release_set_dc();
  
  // optional .lighthouse.Send_Data send_data = 8;
  inline bool has_send_data() const;
  inline void clear_send_data();
  static const int kSendDataFieldNumber = 8;
  inline const ::lighthouse::Send_Data& send_data() const;
  inline ::lighthouse::Send_Data* mutable_send_data();
  inline ::lighthouse::Send_Data* release_send_data();
  
  // optional .lighthouse.Lat_Data lat_data = 9;
  inline bool has_lat_data() const;
  inline void clear_lat_data();
  static const int kLatDataFieldNumber = 9;
  inline const ::lighthouse::Lat_Data& lat_data() const;
  inline ::lighthouse::Lat_Data* mutable_lat_data();
  inline ::lighthouse::Lat_Data* release_lat_data();
  
  // optional .lighthouse.Num_Brds num_brds = 10;
  inline bool has_num_brds() const;
  inline void clear_num_brds();
  static const int kNumBrdsFieldNumber = 10;
  inline const ::lighthouse::Num_Brds& num_brds() const;
  inline ::lighthouse::Num_Brds* mutable_num_brds();
  inline ::lighthouse::Num_Brds* release_num_brds();
  
  // @@protoc_insertion_point(class_scope:lighthouse.Command)
 private:
  inline void set_has_cmd_type();
  inline void clear_has_cmd_type();
  inline void set_has_connect();
  inline void clear_has_connect();
  inline void set_has_disconnect();
  inline void clear_has_disconnect();
  inline void set_has_hello();
  inline void clear_has_hello();
  inline void set_has_en_led();
  inline void clear_has_en_led();
  inline void set_has_dis_led();
  inline void clear_has_dis_led();
  inline void set_has_set_dc();
  inline void clear_has_set_dc();
  inline void set_has_send_data();
  inline void clear_has_send_data();
  inline void set_has_lat_data();
  inline void clear_has_lat_data();
  inline void set_has_num_brds();
  inline void clear_has_num_brds();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::lighthouse::Connect* connect_;
  ::lighthouse::Disconnect* disconnect_;
  ::lighthouse::Hello* hello_;
  ::lighthouse::En_LED* en_led_;
  ::lighthouse::Dis_LED* dis_led_;
  ::lighthouse::Set_DC* set_dc_;
  ::lighthouse::Send_Data* send_data_;
  ::lighthouse::Lat_Data* lat_data_;
  ::lighthouse::Num_Brds* num_brds_;
  int cmd_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_lighthouse_2eproto();
  friend void protobuf_AssignDesc_lighthouse_2eproto();
  friend void protobuf_ShutdownFile_lighthouse_2eproto();
  
  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class Connect : public ::google::protobuf::Message {
 public:
  Connect();
  virtual ~Connect();
  
  Connect(const Connect& from);
  
  inline Connect& operator=(const Connect& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Connect& default_instance();
  
  void Swap(Connect* other);
  
  // implements Message ----------------------------------------------
  
  Connect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Connect& from);
  void MergeFrom(const Connect& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string port = 1;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 1;
  inline const ::std::string& port() const;
  inline void set_port(const ::std::string& value);
  inline void set_port(const char* value);
  inline void set_port(const char* value, size_t size);
  inline ::std::string* mutable_port();
  inline ::std::string* release_port();
  
  // @@protoc_insertion_point(class_scope:lighthouse.Connect)
 private:
  inline void set_has_port();
  inline void clear_has_port();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_lighthouse_2eproto();
  friend void protobuf_AssignDesc_lighthouse_2eproto();
  friend void protobuf_ShutdownFile_lighthouse_2eproto();
  
  void InitAsDefaultInstance();
  static Connect* default_instance_;
};
// -------------------------------------------------------------------

class Disconnect : public ::google::protobuf::Message {
 public:
  Disconnect();
  virtual ~Disconnect();
  
  Disconnect(const Disconnect& from);
  
  inline Disconnect& operator=(const Disconnect& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Disconnect& default_instance();
  
  void Swap(Disconnect* other);
  
  // implements Message ----------------------------------------------
  
  Disconnect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Disconnect& from);
  void MergeFrom(const Disconnect& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:lighthouse.Disconnect)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_lighthouse_2eproto();
  friend void protobuf_AssignDesc_lighthouse_2eproto();
  friend void protobuf_ShutdownFile_lighthouse_2eproto();
  
  void InitAsDefaultInstance();
  static Disconnect* default_instance_;
};
// -------------------------------------------------------------------

class Hello : public ::google::protobuf::Message {
 public:
  Hello();
  virtual ~Hello();
  
  Hello(const Hello& from);
  
  inline Hello& operator=(const Hello& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Hello& default_instance();
  
  void Swap(Hello* other);
  
  // implements Message ----------------------------------------------
  
  Hello* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hello& from);
  void MergeFrom(const Hello& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:lighthouse.Hello)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_lighthouse_2eproto();
  friend void protobuf_AssignDesc_lighthouse_2eproto();
  friend void protobuf_ShutdownFile_lighthouse_2eproto();
  
  void InitAsDefaultInstance();
  static Hello* default_instance_;
};
// -------------------------------------------------------------------

class En_LED : public ::google::protobuf::Message {
 public:
  En_LED();
  virtual ~En_LED();
  
  En_LED(const En_LED& from);
  
  inline En_LED& operator=(const En_LED& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const En_LED& default_instance();
  
  void Swap(En_LED* other);
  
  // implements Message ----------------------------------------------
  
  En_LED* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const En_LED& from);
  void MergeFrom(const En_LED& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:lighthouse.En_LED)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_lighthouse_2eproto();
  friend void protobuf_AssignDesc_lighthouse_2eproto();
  friend void protobuf_ShutdownFile_lighthouse_2eproto();
  
  void InitAsDefaultInstance();
  static En_LED* default_instance_;
};
// -------------------------------------------------------------------

class Dis_LED : public ::google::protobuf::Message {
 public:
  Dis_LED();
  virtual ~Dis_LED();
  
  Dis_LED(const Dis_LED& from);
  
  inline Dis_LED& operator=(const Dis_LED& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Dis_LED& default_instance();
  
  void Swap(Dis_LED* other);
  
  // implements Message ----------------------------------------------
  
  Dis_LED* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Dis_LED& from);
  void MergeFrom(const Dis_LED& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:lighthouse.Dis_LED)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_lighthouse_2eproto();
  friend void protobuf_AssignDesc_lighthouse_2eproto();
  friend void protobuf_ShutdownFile_lighthouse_2eproto();
  
  void InitAsDefaultInstance();
  static Dis_LED* default_instance_;
};
// -------------------------------------------------------------------

class Set_DC : public ::google::protobuf::Message {
 public:
  Set_DC();
  virtual ~Set_DC();
  
  Set_DC(const Set_DC& from);
  
  inline Set_DC& operator=(const Set_DC& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Set_DC& default_instance();
  
  void Swap(Set_DC* other);
  
  // implements Message ----------------------------------------------
  
  Set_DC* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Set_DC& from);
  void MergeFrom(const Set_DC& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);
  
  // required uint32 num_brds = 2;
  inline bool has_num_brds() const;
  inline void clear_num_brds();
  static const int kNumBrdsFieldNumber = 2;
  inline ::google::protobuf::uint32 num_brds() const;
  inline void set_num_brds(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:lighthouse.Set_DC)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_num_brds();
  inline void clear_has_num_brds();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 num_brds_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_lighthouse_2eproto();
  friend void protobuf_AssignDesc_lighthouse_2eproto();
  friend void protobuf_ShutdownFile_lighthouse_2eproto();
  
  void InitAsDefaultInstance();
  static Set_DC* default_instance_;
};
// -------------------------------------------------------------------

class Send_Data : public ::google::protobuf::Message {
 public:
  Send_Data();
  virtual ~Send_Data();
  
  Send_Data(const Send_Data& from);
  
  inline Send_Data& operator=(const Send_Data& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Send_Data& default_instance();
  
  void Swap(Send_Data* other);
  
  // implements Message ----------------------------------------------
  
  Send_Data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Send_Data& from);
  void MergeFrom(const Send_Data& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated uint32 data = 1 [packed = true];
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline ::google::protobuf::uint32 data(int index) const;
  inline void set_data(int index, ::google::protobuf::uint32 value);
  inline void add_data(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      data() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_data();
  
  // @@protoc_insertion_point(class_scope:lighthouse.Send_Data)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > data_;
  mutable int _data_cached_byte_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_lighthouse_2eproto();
  friend void protobuf_AssignDesc_lighthouse_2eproto();
  friend void protobuf_ShutdownFile_lighthouse_2eproto();
  
  void InitAsDefaultInstance();
  static Send_Data* default_instance_;
};
// -------------------------------------------------------------------

class Lat_Data : public ::google::protobuf::Message {
 public:
  Lat_Data();
  virtual ~Lat_Data();
  
  Lat_Data(const Lat_Data& from);
  
  inline Lat_Data& operator=(const Lat_Data& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Lat_Data& default_instance();
  
  void Swap(Lat_Data* other);
  
  // implements Message ----------------------------------------------
  
  Lat_Data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Lat_Data& from);
  void MergeFrom(const Lat_Data& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:lighthouse.Lat_Data)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_lighthouse_2eproto();
  friend void protobuf_AssignDesc_lighthouse_2eproto();
  friend void protobuf_ShutdownFile_lighthouse_2eproto();
  
  void InitAsDefaultInstance();
  static Lat_Data* default_instance_;
};
// -------------------------------------------------------------------

class Num_Brds : public ::google::protobuf::Message {
 public:
  Num_Brds();
  virtual ~Num_Brds();
  
  Num_Brds(const Num_Brds& from);
  
  inline Num_Brds& operator=(const Num_Brds& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Num_Brds& default_instance();
  
  void Swap(Num_Brds* other);
  
  // implements Message ----------------------------------------------
  
  Num_Brds* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Num_Brds& from);
  void MergeFrom(const Num_Brds& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:lighthouse.Num_Brds)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_lighthouse_2eproto();
  friend void protobuf_AssignDesc_lighthouse_2eproto();
  friend void protobuf_ShutdownFile_lighthouse_2eproto();
  
  void InitAsDefaultInstance();
  static Num_Brds* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();
  
  Response(const Response& from);
  
  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();
  
  void Swap(Response* other);
  
  // implements Message ----------------------------------------------
  
  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .lighthouse.Command.Commands cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::lighthouse::Command_Commands cmd() const;
  inline void set_cmd(::lighthouse::Command_Commands value);
  
  // optional .lighthouse.Error error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::lighthouse::Error& error() const;
  inline ::lighthouse::Error* mutable_error();
  inline ::lighthouse::Error* release_error();
  
  // optional .lighthouse.Connect_Resp connect_resp = 3;
  inline bool has_connect_resp() const;
  inline void clear_connect_resp();
  static const int kConnectRespFieldNumber = 3;
  inline const ::lighthouse::Connect_Resp& connect_resp() const;
  inline ::lighthouse::Connect_Resp* mutable_connect_resp();
  inline ::lighthouse::Connect_Resp* release_connect_resp();
  
  // optional .lighthouse.Num_Brds_Resp num_brds_resp = 4;
  inline bool has_num_brds_resp() const;
  inline void clear_num_brds_resp();
  static const int kNumBrdsRespFieldNumber = 4;
  inline const ::lighthouse::Num_Brds_Resp& num_brds_resp() const;
  inline ::lighthouse::Num_Brds_Resp* mutable_num_brds_resp();
  inline ::lighthouse::Num_Brds_Resp* release_num_brds_resp();
  
  // @@protoc_insertion_point(class_scope:lighthouse.Response)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_connect_resp();
  inline void clear_has_connect_resp();
  inline void set_has_num_brds_resp();
  inline void clear_has_num_brds_resp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::lighthouse::Error* error_;
  ::lighthouse::Connect_Resp* connect_resp_;
  ::lighthouse::Num_Brds_Resp* num_brds_resp_;
  int cmd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_lighthouse_2eproto();
  friend void protobuf_AssignDesc_lighthouse_2eproto();
  friend void protobuf_ShutdownFile_lighthouse_2eproto();
  
  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message {
 public:
  Error();
  virtual ~Error();
  
  Error(const Error& from);
  
  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();
  
  void Swap(Error* other);
  
  // implements Message ----------------------------------------------
  
  Error* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Error_Errors Errors;
  static const Errors NO_BRD = Error_Errors_NO_BRD;
  static const Errors NO_PORT = Error_Errors_NO_PORT;
  static const Errors TEMP = Error_Errors_TEMP;
  static const Errors LOD = Error_Errors_LOD;
  static const Errors UNKWN_CMD = Error_Errors_UNKWN_CMD;
  static const Errors UNFMD_CMD = Error_Errors_UNFMD_CMD;
  static inline bool Errors_IsValid(int value) {
    return Error_Errors_IsValid(value);
  }
  static const Errors Errors_MIN =
    Error_Errors_Errors_MIN;
  static const Errors Errors_MAX =
    Error_Errors_Errors_MAX;
  static const int Errors_ARRAYSIZE =
    Error_Errors_Errors_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Errors_descriptor() {
    return Error_Errors_descriptor();
  }
  static inline const ::std::string& Errors_Name(Errors value) {
    return Error_Errors_Name(value);
  }
  static inline bool Errors_Parse(const ::std::string& name,
      Errors* value) {
    return Error_Errors_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .lighthouse.Error.Errors error_type = 1;
  inline bool has_error_type() const;
  inline void clear_error_type();
  static const int kErrorTypeFieldNumber = 1;
  inline ::lighthouse::Error_Errors error_type() const;
  inline void set_error_type(::lighthouse::Error_Errors value);
  
  // optional string string = 2;
  inline bool has_string() const;
  inline void clear_string();
  static const int kStringFieldNumber = 2;
  inline const ::std::string& string() const;
  inline void set_string(const ::std::string& value);
  inline void set_string(const char* value);
  inline void set_string(const char* value, size_t size);
  inline ::std::string* mutable_string();
  inline ::std::string* release_string();
  
  // @@protoc_insertion_point(class_scope:lighthouse.Error)
 private:
  inline void set_has_error_type();
  inline void clear_has_error_type();
  inline void set_has_string();
  inline void clear_has_string();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* string_;
  int error_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_lighthouse_2eproto();
  friend void protobuf_AssignDesc_lighthouse_2eproto();
  friend void protobuf_ShutdownFile_lighthouse_2eproto();
  
  void InitAsDefaultInstance();
  static Error* default_instance_;
};
// -------------------------------------------------------------------

class Connect_Resp : public ::google::protobuf::Message {
 public:
  Connect_Resp();
  virtual ~Connect_Resp();
  
  Connect_Resp(const Connect_Resp& from);
  
  inline Connect_Resp& operator=(const Connect_Resp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Connect_Resp& default_instance();
  
  void Swap(Connect_Resp* other);
  
  // implements Message ----------------------------------------------
  
  Connect_Resp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Connect_Resp& from);
  void MergeFrom(const Connect_Resp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string port = 1;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 1;
  inline const ::std::string& port() const;
  inline void set_port(const ::std::string& value);
  inline void set_port(const char* value);
  inline void set_port(const char* value, size_t size);
  inline ::std::string* mutable_port();
  inline ::std::string* release_port();
  
  // @@protoc_insertion_point(class_scope:lighthouse.Connect_Resp)
 private:
  inline void set_has_port();
  inline void clear_has_port();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_lighthouse_2eproto();
  friend void protobuf_AssignDesc_lighthouse_2eproto();
  friend void protobuf_ShutdownFile_lighthouse_2eproto();
  
  void InitAsDefaultInstance();
  static Connect_Resp* default_instance_;
};
// -------------------------------------------------------------------

class Num_Brds_Resp : public ::google::protobuf::Message {
 public:
  Num_Brds_Resp();
  virtual ~Num_Brds_Resp();
  
  Num_Brds_Resp(const Num_Brds_Resp& from);
  
  inline Num_Brds_Resp& operator=(const Num_Brds_Resp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Num_Brds_Resp& default_instance();
  
  void Swap(Num_Brds_Resp* other);
  
  // implements Message ----------------------------------------------
  
  Num_Brds_Resp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Num_Brds_Resp& from);
  void MergeFrom(const Num_Brds_Resp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 num_brds = 1;
  inline bool has_num_brds() const;
  inline void clear_num_brds();
  static const int kNumBrdsFieldNumber = 1;
  inline ::google::protobuf::uint32 num_brds() const;
  inline void set_num_brds(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:lighthouse.Num_Brds_Resp)
 private:
  inline void set_has_num_brds();
  inline void clear_has_num_brds();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 num_brds_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_lighthouse_2eproto();
  friend void protobuf_AssignDesc_lighthouse_2eproto();
  friend void protobuf_ShutdownFile_lighthouse_2eproto();
  
  void InitAsDefaultInstance();
  static Num_Brds_Resp* default_instance_;
};
// ===================================================================


// ===================================================================

// Command

// required .lighthouse.Command.Commands cmd_type = 1;
inline bool Command::has_cmd_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_cmd_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_cmd_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_cmd_type() {
  cmd_type_ = 1;
  clear_has_cmd_type();
}
inline ::lighthouse::Command_Commands Command::cmd_type() const {
  return static_cast< ::lighthouse::Command_Commands >(cmd_type_);
}
inline void Command::set_cmd_type(::lighthouse::Command_Commands value) {
  GOOGLE_DCHECK(::lighthouse::Command_Commands_IsValid(value));
  set_has_cmd_type();
  cmd_type_ = value;
}

// optional .lighthouse.Connect connect = 2;
inline bool Command::has_connect() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command::set_has_connect() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command::clear_has_connect() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command::clear_connect() {
  if (connect_ != NULL) connect_->::lighthouse::Connect::Clear();
  clear_has_connect();
}
inline const ::lighthouse::Connect& Command::connect() const {
  return connect_ != NULL ? *connect_ : *default_instance_->connect_;
}
inline ::lighthouse::Connect* Command::mutable_connect() {
  set_has_connect();
  if (connect_ == NULL) connect_ = new ::lighthouse::Connect;
  return connect_;
}
inline ::lighthouse::Connect* Command::release_connect() {
  clear_has_connect();
  ::lighthouse::Connect* temp = connect_;
  connect_ = NULL;
  return temp;
}

// optional .lighthouse.Disconnect disconnect = 3;
inline bool Command::has_disconnect() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command::set_has_disconnect() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command::clear_has_disconnect() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command::clear_disconnect() {
  if (disconnect_ != NULL) disconnect_->::lighthouse::Disconnect::Clear();
  clear_has_disconnect();
}
inline const ::lighthouse::Disconnect& Command::disconnect() const {
  return disconnect_ != NULL ? *disconnect_ : *default_instance_->disconnect_;
}
inline ::lighthouse::Disconnect* Command::mutable_disconnect() {
  set_has_disconnect();
  if (disconnect_ == NULL) disconnect_ = new ::lighthouse::Disconnect;
  return disconnect_;
}
inline ::lighthouse::Disconnect* Command::release_disconnect() {
  clear_has_disconnect();
  ::lighthouse::Disconnect* temp = disconnect_;
  disconnect_ = NULL;
  return temp;
}

// optional .lighthouse.Hello hello = 4;
inline bool Command::has_hello() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command::set_has_hello() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command::clear_has_hello() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command::clear_hello() {
  if (hello_ != NULL) hello_->::lighthouse::Hello::Clear();
  clear_has_hello();
}
inline const ::lighthouse::Hello& Command::hello() const {
  return hello_ != NULL ? *hello_ : *default_instance_->hello_;
}
inline ::lighthouse::Hello* Command::mutable_hello() {
  set_has_hello();
  if (hello_ == NULL) hello_ = new ::lighthouse::Hello;
  return hello_;
}
inline ::lighthouse::Hello* Command::release_hello() {
  clear_has_hello();
  ::lighthouse::Hello* temp = hello_;
  hello_ = NULL;
  return temp;
}

// optional .lighthouse.En_LED en_led = 5;
inline bool Command::has_en_led() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Command::set_has_en_led() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Command::clear_has_en_led() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Command::clear_en_led() {
  if (en_led_ != NULL) en_led_->::lighthouse::En_LED::Clear();
  clear_has_en_led();
}
inline const ::lighthouse::En_LED& Command::en_led() const {
  return en_led_ != NULL ? *en_led_ : *default_instance_->en_led_;
}
inline ::lighthouse::En_LED* Command::mutable_en_led() {
  set_has_en_led();
  if (en_led_ == NULL) en_led_ = new ::lighthouse::En_LED;
  return en_led_;
}
inline ::lighthouse::En_LED* Command::release_en_led() {
  clear_has_en_led();
  ::lighthouse::En_LED* temp = en_led_;
  en_led_ = NULL;
  return temp;
}

// optional .lighthouse.Dis_LED dis_led = 6;
inline bool Command::has_dis_led() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Command::set_has_dis_led() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Command::clear_has_dis_led() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Command::clear_dis_led() {
  if (dis_led_ != NULL) dis_led_->::lighthouse::Dis_LED::Clear();
  clear_has_dis_led();
}
inline const ::lighthouse::Dis_LED& Command::dis_led() const {
  return dis_led_ != NULL ? *dis_led_ : *default_instance_->dis_led_;
}
inline ::lighthouse::Dis_LED* Command::mutable_dis_led() {
  set_has_dis_led();
  if (dis_led_ == NULL) dis_led_ = new ::lighthouse::Dis_LED;
  return dis_led_;
}
inline ::lighthouse::Dis_LED* Command::release_dis_led() {
  clear_has_dis_led();
  ::lighthouse::Dis_LED* temp = dis_led_;
  dis_led_ = NULL;
  return temp;
}

// optional .lighthouse.Set_DC set_dc = 7;
inline bool Command::has_set_dc() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Command::set_has_set_dc() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Command::clear_has_set_dc() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Command::clear_set_dc() {
  if (set_dc_ != NULL) set_dc_->::lighthouse::Set_DC::Clear();
  clear_has_set_dc();
}
inline const ::lighthouse::Set_DC& Command::set_dc() const {
  return set_dc_ != NULL ? *set_dc_ : *default_instance_->set_dc_;
}
inline ::lighthouse::Set_DC* Command::mutable_set_dc() {
  set_has_set_dc();
  if (set_dc_ == NULL) set_dc_ = new ::lighthouse::Set_DC;
  return set_dc_;
}
inline ::lighthouse::Set_DC* Command::release_set_dc() {
  clear_has_set_dc();
  ::lighthouse::Set_DC* temp = set_dc_;
  set_dc_ = NULL;
  return temp;
}

// optional .lighthouse.Send_Data send_data = 8;
inline bool Command::has_send_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Command::set_has_send_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Command::clear_has_send_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Command::clear_send_data() {
  if (send_data_ != NULL) send_data_->::lighthouse::Send_Data::Clear();
  clear_has_send_data();
}
inline const ::lighthouse::Send_Data& Command::send_data() const {
  return send_data_ != NULL ? *send_data_ : *default_instance_->send_data_;
}
inline ::lighthouse::Send_Data* Command::mutable_send_data() {
  set_has_send_data();
  if (send_data_ == NULL) send_data_ = new ::lighthouse::Send_Data;
  return send_data_;
}
inline ::lighthouse::Send_Data* Command::release_send_data() {
  clear_has_send_data();
  ::lighthouse::Send_Data* temp = send_data_;
  send_data_ = NULL;
  return temp;
}

// optional .lighthouse.Lat_Data lat_data = 9;
inline bool Command::has_lat_data() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Command::set_has_lat_data() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Command::clear_has_lat_data() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Command::clear_lat_data() {
  if (lat_data_ != NULL) lat_data_->::lighthouse::Lat_Data::Clear();
  clear_has_lat_data();
}
inline const ::lighthouse::Lat_Data& Command::lat_data() const {
  return lat_data_ != NULL ? *lat_data_ : *default_instance_->lat_data_;
}
inline ::lighthouse::Lat_Data* Command::mutable_lat_data() {
  set_has_lat_data();
  if (lat_data_ == NULL) lat_data_ = new ::lighthouse::Lat_Data;
  return lat_data_;
}
inline ::lighthouse::Lat_Data* Command::release_lat_data() {
  clear_has_lat_data();
  ::lighthouse::Lat_Data* temp = lat_data_;
  lat_data_ = NULL;
  return temp;
}

// optional .lighthouse.Num_Brds num_brds = 10;
inline bool Command::has_num_brds() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Command::set_has_num_brds() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Command::clear_has_num_brds() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Command::clear_num_brds() {
  if (num_brds_ != NULL) num_brds_->::lighthouse::Num_Brds::Clear();
  clear_has_num_brds();
}
inline const ::lighthouse::Num_Brds& Command::num_brds() const {
  return num_brds_ != NULL ? *num_brds_ : *default_instance_->num_brds_;
}
inline ::lighthouse::Num_Brds* Command::mutable_num_brds() {
  set_has_num_brds();
  if (num_brds_ == NULL) num_brds_ = new ::lighthouse::Num_Brds;
  return num_brds_;
}
inline ::lighthouse::Num_Brds* Command::release_num_brds() {
  clear_has_num_brds();
  ::lighthouse::Num_Brds* temp = num_brds_;
  num_brds_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Connect

// optional string port = 1;
inline bool Connect::has_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Connect::set_has_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Connect::clear_has_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Connect::clear_port() {
  if (port_ != &::google::protobuf::internal::kEmptyString) {
    port_->clear();
  }
  clear_has_port();
}
inline const ::std::string& Connect::port() const {
  return *port_;
}
inline void Connect::set_port(const ::std::string& value) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::kEmptyString) {
    port_ = new ::std::string;
  }
  port_->assign(value);
}
inline void Connect::set_port(const char* value) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::kEmptyString) {
    port_ = new ::std::string;
  }
  port_->assign(value);
}
inline void Connect::set_port(const char* value, size_t size) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::kEmptyString) {
    port_ = new ::std::string;
  }
  port_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Connect::mutable_port() {
  set_has_port();
  if (port_ == &::google::protobuf::internal::kEmptyString) {
    port_ = new ::std::string;
  }
  return port_;
}
inline ::std::string* Connect::release_port() {
  clear_has_port();
  if (port_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = port_;
    port_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Disconnect

// -------------------------------------------------------------------

// Hello

// -------------------------------------------------------------------

// En_LED

// -------------------------------------------------------------------

// Dis_LED

// -------------------------------------------------------------------

// Set_DC

// required uint32 level = 1;
inline bool Set_DC::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Set_DC::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Set_DC::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Set_DC::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 Set_DC::level() const {
  return level_;
}
inline void Set_DC::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// required uint32 num_brds = 2;
inline bool Set_DC::has_num_brds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Set_DC::set_has_num_brds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Set_DC::clear_has_num_brds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Set_DC::clear_num_brds() {
  num_brds_ = 0u;
  clear_has_num_brds();
}
inline ::google::protobuf::uint32 Set_DC::num_brds() const {
  return num_brds_;
}
inline void Set_DC::set_num_brds(::google::protobuf::uint32 value) {
  set_has_num_brds();
  num_brds_ = value;
}

// -------------------------------------------------------------------

// Send_Data

// repeated uint32 data = 1 [packed = true];
inline int Send_Data::data_size() const {
  return data_.size();
}
inline void Send_Data::clear_data() {
  data_.Clear();
}
inline ::google::protobuf::uint32 Send_Data::data(int index) const {
  return data_.Get(index);
}
inline void Send_Data::set_data(int index, ::google::protobuf::uint32 value) {
  data_.Set(index, value);
}
inline void Send_Data::add_data(::google::protobuf::uint32 value) {
  data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Send_Data::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Send_Data::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// Lat_Data

// -------------------------------------------------------------------

// Num_Brds

// -------------------------------------------------------------------

// Response

// required .lighthouse.Command.Commands cmd = 1;
inline bool Response::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::lighthouse::Command_Commands Response::cmd() const {
  return static_cast< ::lighthouse::Command_Commands >(cmd_);
}
inline void Response::set_cmd(::lighthouse::Command_Commands value) {
  GOOGLE_DCHECK(::lighthouse::Command_Commands_IsValid(value));
  set_has_cmd();
  cmd_ = value;
}

// optional .lighthouse.Error error = 2;
inline bool Response::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_error() {
  if (error_ != NULL) error_->::lighthouse::Error::Clear();
  clear_has_error();
}
inline const ::lighthouse::Error& Response::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::lighthouse::Error* Response::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::lighthouse::Error;
  return error_;
}
inline ::lighthouse::Error* Response::release_error() {
  clear_has_error();
  ::lighthouse::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// optional .lighthouse.Connect_Resp connect_resp = 3;
inline bool Response::has_connect_resp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_connect_resp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_connect_resp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_connect_resp() {
  if (connect_resp_ != NULL) connect_resp_->::lighthouse::Connect_Resp::Clear();
  clear_has_connect_resp();
}
inline const ::lighthouse::Connect_Resp& Response::connect_resp() const {
  return connect_resp_ != NULL ? *connect_resp_ : *default_instance_->connect_resp_;
}
inline ::lighthouse::Connect_Resp* Response::mutable_connect_resp() {
  set_has_connect_resp();
  if (connect_resp_ == NULL) connect_resp_ = new ::lighthouse::Connect_Resp;
  return connect_resp_;
}
inline ::lighthouse::Connect_Resp* Response::release_connect_resp() {
  clear_has_connect_resp();
  ::lighthouse::Connect_Resp* temp = connect_resp_;
  connect_resp_ = NULL;
  return temp;
}

// optional .lighthouse.Num_Brds_Resp num_brds_resp = 4;
inline bool Response::has_num_brds_resp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_num_brds_resp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_num_brds_resp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_num_brds_resp() {
  if (num_brds_resp_ != NULL) num_brds_resp_->::lighthouse::Num_Brds_Resp::Clear();
  clear_has_num_brds_resp();
}
inline const ::lighthouse::Num_Brds_Resp& Response::num_brds_resp() const {
  return num_brds_resp_ != NULL ? *num_brds_resp_ : *default_instance_->num_brds_resp_;
}
inline ::lighthouse::Num_Brds_Resp* Response::mutable_num_brds_resp() {
  set_has_num_brds_resp();
  if (num_brds_resp_ == NULL) num_brds_resp_ = new ::lighthouse::Num_Brds_Resp;
  return num_brds_resp_;
}
inline ::lighthouse::Num_Brds_Resp* Response::release_num_brds_resp() {
  clear_has_num_brds_resp();
  ::lighthouse::Num_Brds_Resp* temp = num_brds_resp_;
  num_brds_resp_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Error

// required .lighthouse.Error.Errors error_type = 1;
inline bool Error::has_error_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Error::set_has_error_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Error::clear_has_error_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Error::clear_error_type() {
  error_type_ = 1;
  clear_has_error_type();
}
inline ::lighthouse::Error_Errors Error::error_type() const {
  return static_cast< ::lighthouse::Error_Errors >(error_type_);
}
inline void Error::set_error_type(::lighthouse::Error_Errors value) {
  GOOGLE_DCHECK(::lighthouse::Error_Errors_IsValid(value));
  set_has_error_type();
  error_type_ = value;
}

// optional string string = 2;
inline bool Error::has_string() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Error::set_has_string() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Error::clear_has_string() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Error::clear_string() {
  if (string_ != &::google::protobuf::internal::kEmptyString) {
    string_->clear();
  }
  clear_has_string();
}
inline const ::std::string& Error::string() const {
  return *string_;
}
inline void Error::set_string(const ::std::string& value) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(value);
}
inline void Error::set_string(const char* value) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(value);
}
inline void Error::set_string(const char* value, size_t size) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Error::mutable_string() {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  return string_;
}
inline ::std::string* Error::release_string() {
  clear_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = string_;
    string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Connect_Resp

// required string port = 1;
inline bool Connect_Resp::has_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Connect_Resp::set_has_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Connect_Resp::clear_has_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Connect_Resp::clear_port() {
  if (port_ != &::google::protobuf::internal::kEmptyString) {
    port_->clear();
  }
  clear_has_port();
}
inline const ::std::string& Connect_Resp::port() const {
  return *port_;
}
inline void Connect_Resp::set_port(const ::std::string& value) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::kEmptyString) {
    port_ = new ::std::string;
  }
  port_->assign(value);
}
inline void Connect_Resp::set_port(const char* value) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::kEmptyString) {
    port_ = new ::std::string;
  }
  port_->assign(value);
}
inline void Connect_Resp::set_port(const char* value, size_t size) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::kEmptyString) {
    port_ = new ::std::string;
  }
  port_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Connect_Resp::mutable_port() {
  set_has_port();
  if (port_ == &::google::protobuf::internal::kEmptyString) {
    port_ = new ::std::string;
  }
  return port_;
}
inline ::std::string* Connect_Resp::release_port() {
  clear_has_port();
  if (port_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = port_;
    port_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Num_Brds_Resp

// required uint32 num_brds = 1;
inline bool Num_Brds_Resp::has_num_brds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Num_Brds_Resp::set_has_num_brds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Num_Brds_Resp::clear_has_num_brds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Num_Brds_Resp::clear_num_brds() {
  num_brds_ = 0u;
  clear_has_num_brds();
}
inline ::google::protobuf::uint32 Num_Brds_Resp::num_brds() const {
  return num_brds_;
}
inline void Num_Brds_Resp::set_num_brds(::google::protobuf::uint32 value) {
  set_has_num_brds();
  num_brds_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace lighthouse

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lighthouse::Command_Commands>() {
  return ::lighthouse::Command_Commands_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lighthouse::Error_Errors>() {
  return ::lighthouse::Error_Errors_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_lighthouse_2eproto__INCLUDED
